


class TraficoAvionesPolitica:
    def __init__(self, seed: int = 42) -> None:
        self.rng = random.Random(seed) # genera num aleatorios para apariciones
        self.next_id = 1 # próximo id a asignar
        self.planes: Dict[int, Avion] = {}
        self.activos: List[int] = []      # ids en approach (ordenados por ETA ascendente)
        self.turnaround: List[int] = []   # ids en turnaround
        self.inactivos: List[int] = []    # ids en diverted | landed
        # Set de ids que acaban de pasar a turnaround para no moverlos en el mismo paso
        self.recien_turnaround: Set[int] = set()

    def aparicion(self, minuto: int) -> Avion:
        ''' crear un avion'''
        aid = self.next_id
        self.next_id += 1
        av = Avion(id=aid, aparicion_min=minuto, distancia_nm=100.0, velocidad_kts=300.0, estado="approach")
        self.planes[aid] = av
        self.activos.append(aid)
        return av

    def ordenar_activos(self, current_speeds: Optional[Dict[int, float]] = None):
        '''
        current_speeds es una "foto" de las velocidades actuales (id -> vel_kts).
        Se usa para ordenar por ETA consistente dentro del paso.
        '''
        if not self.activos:
            return
        def tiempo_estimado(aid: int) -> float:
            av = self.planes[aid]
            v = av.velocidad_kts if current_speeds is None else current_speeds[aid]
            return av.tiempo_a_aep(v)
        self.activos.sort(key=tiempo_estimado)
        # actualizar punteros a líder (anterior en ETA)
        for i, aid in enumerate(self.activos):
            av = self.planes[aid]
            av.leader_id = self.activos[i-1] if i > 0 else None

    def control_paso(self) -> None:
        '''
        Reordena y decide velocidades/estados por un paso:
        1) Ordena activos y setea punteros a líder.
        2) Para cada avión en approach:
           - Chequeo de seguridad (gap < SEPARACION_PELIGRO) -> frenar fuerte o pasar a turnaround.
           - Si no hay peligro, aplica Política A (metering):
             apuntar a ETA = ETA_líder + g_objetivo(dist) con límites de banda.
        3) Intenta reinsertar desde turnaround a huecos globales.
        '''
        # Foto de dist/vel previas a las decisiones del paso
        speed_prev = {aid: self.planes[aid].velocidad_kts for aid in self.activos}
        dist_prev  = {aid: self.planes[aid].distancia_nm  for aid in self.activos}
        # Orden consistente usando la foto
        self.ordenar_activos(current_speeds=speed_prev)

        # limpiar marcas de "recién enviados a turnaround" para este paso
        self.recien_turnaround.clear()

        # --- Decidir en carril approach ---
        for aid in list(self.activos):
            av = self.planes[aid]
            vmin, vmax = velocidad_por_distancia(dist_prev[aid])

            leader_id = av.leader_id
            if leader_id is None:
                # Sin líder: nadie delante -> ir a vmax (no hacemos metering al primero)
                av.velocidad_kts = vmax
                continue

            # ETA del líder con su velocidad previa (foto consistente del paso)
            my_mins_to_aep = mins_a_aep(dist_prev[aid], speed_prev[aid])
            lead_mins_to_aep = mins_a_aep(dist_prev[leader_id], speed_prev[leader_id])

            # --- 1) Chequeo de seguridad (fallback original) ---
            # Gap "pesimista" evaluado si YO fuera a vmax (peor caso para separación).
            gap = my_mins_to_aep - lead_mins_to_aep

            if gap < SEPARACION_PELIGRO:
                # Como antes: tratar de frenar 20 kts por debajo del líder. Si no alcanza, turnaround.
                nueva_vel = min(vmax, speed_prev[leader_id] - 20.0)
                if nueva_vel < vmin:
                    av.estado = "turnaround"
                    av.velocidad_kts = VEL_TURNAROUND
                    self.mover_a_turnaround(aid)
                    self.recien_turnaround.add(aid)  # para no moverlo en este mismo step
                else:
                    av.velocidad_kts = max(vmin, nueva_vel)
                continue  # ya resolvimos el caso de peligro; saltamos metering

            # --- 2) Política A (metering anticipado) en zona segura ---
            # Predicción de gap si YO me mantuviera a vmax (no hay peligro, pero puede haber "compresión").
            my_mins_to_aep_vmax = mins_a_aep(dist_prev[aid], vmax)
            gap_pesimista = my_mins_to_aep_vmax - lead_mins_to_aep
            pred_gap = gap_pesimista  # ya lo calculamos con my_mins_to_aep_vmax

            # Target deseado según distancia (más grande lejos), con un pequeño buffer
            g_target = g_objetivo(dist_prev[aid])

            if pred_gap < g_target + BUFFER_ANTICIPACION:
                # Queremos llegar a t_target = ETA_líder + g_target
                t_target = lead_mins_to_aep + g_target
                # Velocidad requerida (nm/min -> kts) respetando límites físicos de la banda
                v_req = (dist_prev[aid] / t_target) * 60.0 if t_target > 0 else vmax
                v_req = min(max(v_req, vmin), vmax)
                av.velocidad_kts = v_req
            else:
                # Ya hay suficiente aire -> mantener vmax (política "no interferir")
                av.velocidad_kts = vmax

        # Intento de reingreso global desde turnaround (tu lógica original)
        activos_order = list(self.activos)
        self.intentar_reingreso(activos_order)

    def mover_a_turnaround(self, aid: int) -> None:
        ''' mueve un avión del carril activo al carril turnaround '''
        if aid in self.activos:
            self.activos.remove(aid)
        if aid not in self.turnaround:
            self.turnaround.append(aid)
        self.planes[aid].leader_id = None

    def mover_a_activos(self, aid: int) -> None:
        ''' mueve un avión del carril turnaround al carril activo cuando reingresa '''
        if aid in self.turnaround:
            self.turnaround.remove(aid)
        if aid not in self.activos:
            self.activos.append(aid)

    def mover_a_inactivos(self, aid: int) -> None:
        ''' mueve un avión del carril activo o turnaround a inactivos (landed o diverted) '''
        if aid in self.activos:
            self.activos.remove(aid)
        if aid in self.turnaround:
            self.turnaround.remove(aid)
        if aid not in self.inactivos:
            self.inactivos.append(aid)
        self.planes[aid].leader_id = None

    # Reingreso desde turnaround: busca huecos globales y ajusta velocidad
    def intentar_reingreso(self, activos_order: List[int]) -> None:
        if not activos_order:
            # Sin nadie en approach -> todos reingresan directo a vmax
            for aid in list(self.turnaround):
                av = self.planes[aid]
                vmin, vmax = av.limites_velocidad()
                av.velocidad_kts = vmax
                av.estado = "approach"
                self.mover_a_activos(aid)
            return

        activos_mins_to_aep = [(aid, self.planes[aid].tiempo_a_aep()) for aid in activos_order]
        activos_mins_to_aep.sort(key=lambda x: x[1])

        for aid in list(self.turnaround):
            av = self.planes[aid]
            d = av.distancia_nm
            vmin, vmax = av.limites_velocidad()
            mins_to_aep_fast = mins_a_aep(d, vmax)
            mins_to_aep_slow = mins_a_aep(d, vmin)

            reinsertado = False
            # Buscar gap entre pares consecutivos
            for (a1, t1), (a2, t2) in zip(activos_mins_to_aep, activos_mins_to_aep[1:]):
                t_low  = t1 + SEPARACION_MINIMA
                t_high = t2 - SEPARACION_MINIMA
                if t_high < t_low:
                    continue

                a = max(t_low, mins_to_aep_fast)
                b = min(t_high, mins_to_aep_slow)
                if a <= b:
                    t_target = (a + b) / 2.0
                    v_target = (d / t_target) * 60.0
                    v_target = min(max(v_target, vmin), vmax)
                    my_eta = mins_a_aep(d, v_target)
                    if t_low <= my_eta <= t_high:
                        av.velocidad_kts = v_target
                        av.estado = "approach"
                        self.mover_a_activos(aid)
                        reinsertado = True
                        break

            # Antes del primero
            if not reinsertado:
                first_eta = activos_mins_to_aep[0][1]
                t_high = first_eta - SEPARACION_MINIMA
                a = mins_to_aep_fast
                b = min(t_high, mins_to_aep_slow)
                if a <= b:
                    t_target = (a + b) / 2.0
                    v_target = (d / t_target) * 60.0
                    v_target = min(max(v_target, vmin), vmax)
                    my_eta = mins_a_aep(d, v_target)
                    if my_eta <= t_high:
                        av.velocidad_kts = v_target
                        av.estado = "approach"
                        self.mover_a_activos(aid)
                        reinsertado = True

            # Después del último
            if not reinsertado:
                last_eta = activos_mins_to_aep[-1][1]
                t_low = last_eta + SEPARACION_MINIMA
                a = max(t_low, mins_to_aep_fast)
                b = mins_to_aep_slow
                if a <= b:
                    t_target = (a + b) / 2.0
                    v_target = (d / t_target) * 60.0
                    v_target = min(max(v_target, vmin), vmax)
                    my_eta = mins_a_aep(d, v_target)
                    if my_eta >= t_low:
                        av.velocidad_kts = v_target
                        av.estado = "approach"
                        self.mover_a_activos(aid)
                        reinsertado = True
            # Si no reinsertó: sigue en turnaround

    def mover_paso(self) -> None:
        # approach
        for aid in list(self.activos):
            av = self.planes[aid]
            avance_nm = knots_to_nm_per_min(av.velocidad_kts) * MINUTE
            av.distancia_nm = max(0.0, av.distancia_nm - avance_nm)
            if av.distancia_nm <= 0.0: # llegó a aep
                av.distancia_nm = 0.0
                av.velocidad_kts = 0.0
                av.estado = "landed"
                self.mover_a_inactivos(aid)
        # turnaround
        for aid in list(self.turnaround):
            av = self.planes[aid]
            if aid in self.recien_turnaround:
                # no mover en el mismo paso del cambio a turnaround
                continue
            retro_nm = knots_to_nm_per_min(VEL_TURNAROUND) * MINUTE
            av.distancia_nm += retro_nm
            if av.distancia_nm >= MAX_DIVERTED_DISTANCE:
                av.estado = "diverted"
                self.mover_a_inactivos(aid)
        # recalcular orden y líderes para próximo paso
        self.ordenar_activos()

    def bernoulli_aparicion(self, lam_per_min: float, t0: int = DAY_START, t1: int = DAY_END) -> List[int]:
        '''
        devuelve una lista de los t's en los que aparecen los aviones
        la bernoulli es una aproximación de la forma discreta al proceso de Poisson
        '''
        apariciones = []
        for t in range(t0, t1):
            if self.rng.random() < lam_per_min:
                apariciones.append(t)
        return apariciones

    def step(self, minuto: int, aparicion: bool) -> None:
        if aparicion:
            self.aparicion(minuto)
        self.control_paso()
        self.mover_paso()